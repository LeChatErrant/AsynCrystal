crystal_doc_search_index_callback({"repository_name":"github.com/LeChatErrant/async","body":"# async\n\n[![Build Status](https://travis-ci.org/LeChatErrant/async.svg?branch=master)](https://travis-ci.org/LeChatErrant/async)\n[![star this repo](http://githubbadges.com/star.svg?user=LeChatErrant&repo=async&style=default)](https://github.com/LeChatErrant/async)\n[![fork this repo](http://githubbadges.com/fork.svg?user=LeChatErrant&repo=async&style=default)](https://github.com/LeChatErrant/async/fork)\n[![GitHub Issues](https://img.shields.io/github/issues/LeChatErrant/async.svg)](https://github.com/LeChatErrant/async/issues)\n[![GitHub contributors](https://img.shields.io/github/contributors/LeChatErrant/async.svg)](https://GitHub.com/LeChatErrant/async/graphs/contributors/)\n![Contributions welcome](https://img.shields.io/badge/contributions-welcome-green.svg)\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT)\n> Promises based tools to manage asynchronous tasks in crystal\n\n### Note from the creator\n\nHello guys! ;)\n\nThis little baby is still under heavy development. You can see my roadmap below!\n\nThis will be updated with the release of a stable version\n\n## Async\n\nThe purpose of Async is to offer a collection of usefull tools to handle asynchronous tasks in crystal.\n\nIt comes with :\n\n - Promise, a wrapper allowing the user to do complex actions in only one line, such as\n   - Waiting for a task to be completed\n   - Running task in background and get their result later\n   - Assigning callbacks on success / error for an asynchronous task\n   - and many many more! ;)\n\n - Pool, a tool based on a classic thread pool architecture. It allows the user to\n   - launch multiple asynchronous workers, always ready to execute tasks\n   - add tasks to the pool. Workers will take it for you and execute it asynchronously in the bakckground!\n   - control the execution of MANY jobs simultaneous with different methods\n   - not to relaunch, for example, a Thread, each time you want to launch an action in the background : here, the workers are launched only ONE time, and are picking differents tasks!\n\nEvery class comes with three different implementation, each time using a different type of worker :\n - Fibers : native crystal green thread, those you can invoke using `spawn`\n - Threads : as crystal doesn't natively support threads for the moment, it is based on C bindings of pthread\n - Process : an entire process, with a lighter memory\n\n\n___\n\nFeel free to contribute, or to send tips !\n\nAnd don't hesitate to give a star if you like it, of course!\n\n____\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n```yaml\ndependencies:\n  async:\n    github: LeChatErrant/async\n```\n\n2. Run `shards install`\n\n## Documentation\n\n> The documentation is not ready for now, as the project is still in development and subject to changes\n\nhttps://lechaterrant.github.io/async/\n\n## Usage\n\n```crystal\nrequire \"async\"\n\ninclude Async\n```\n\n___\n\n### Promise\n\n> Promises are still currently in development! ;) I'm actually working on callbacks, and their Thread version will come soon\n\nPromise is a wrapper around an asynchronous task. This task can be handled with a crystal Fiber, a Thread, or a Process, respectively with FiberPromise, ThreadPromise, and ProcessPromise.\n\nIt is build on the Promise model of Javascript (ES6), and allow multiple action with it\n\nEach Promise has the same api (see Documentation), see below for an example using FiberPromise\n\n#### Creating a Promise\n\nKeep in mind that here, we're working with FiberPromise, so the asynchronous task is launched in a Fiber. With a ThreadPool, it would have been a Thread, and with a ProcessPool, an entire Process\n\nUsing bracket notation\n\n```crystal\npromise = FiberPromise.new(->{ puts \"Hello\" })\n# Notice that creating a Promise immediatly launches the wrapped Proc\n```\n\nUsing do/end notation\n\n```crystal\npromise = FiberPromise.new(->(arg : String) do\n  puts arg\nend, \"Hello\")\n# Notice that arguments are given after the Proc\n# You code won't compile if you forget an argument\n```\n\nFrom an existing function\n\n```crystal\ndef say(arg : String)\n  puts arg\nend\n\nproc_say = ->say(String)\npromise = FiberPromise.new(proc_say, \"Hello)\n# Or simply\npromise = FiberPromise.new(->say(String), \"Hello\")\n```\n\n#### Waiting a Promise\n\n`await` block the execution until the given Proc is finished\n\n```crystal\nawait FiberPromise.new(-> do\n  puts \"time for a nap!\"\n  sleep 2.seconds\n  puts \"zzz...\"\n  sleep 2.seconds\n  puts \"I'm awake! :)\"\nend)\nputs \"I'm after await\"\n```\n\nIt's usefull to wait for a specific task before your program continues\n\nWaiting for an already resolved Promise won't have any effect\n\n```crystal\npromise = FiberPromise.new(->{ puts \"hello\" })\nawait promise\n```\n\n#### Return value\n\nTry to display a promise : you'll get its state!\n\n```crystal\nputs promise  # #<Async::FiberPromise:object_id> PENDING\nputs promise.state  # PENDING\n# .get will return it's state too until resolved\nputs promise.get  # PENDING\n```\n\nA promise is said PENDING when currently executed, RESOLVED when finished, and REJECTED if an error was thrown\n\nWhen the promise is resolved, you can access its value\n\n```crystal\npromised_value = await promise\nputs promised_value # returned value\nputs promise.get  # returned value\nputs promise.state  # RESOLVED\nputs promise  # #<Async::FiberPromise:object_id> RESOLVED\n```\n\nCrystal can't infer the type of the returned value at compile time. For example, the following code won't compile\n\n```crystal\nvalue = await FiberPromise.new(->{ \"I am a String\" })\nputs value.split \" \"    # Compile time error, as Crystal is not sure that value is a String\n```\n\nYou can fix this problem by enforcing the type with the `.as` method\n\n```crystal\nvalue = await FiberPromise.new(->{ resolve \"I am a String\" })\nputs value.as(String).split \" \"\n```\n\nBut be careful! If the returned value was not a String, your code will crash\n\nPrefer using a typed `await` instead of the `.as` notation\n\n```crystal\nvalue = await String, FiberPromise.new(->{ resolve \"I am a String and I know it!\" })\nputs value.split \" \"\n```\n\nOf course, you can use the keyword `return` inside a Promise, and return different types of values, and multiple values at the same time\n\n```crystal\nconditionnal_proc = ->(toggle : Bool) do\n  if toggle\n    return \"I received true! :)\"\n  end\n  return false, \"I received false... :(\"\nend\nputs await FiberPromise.new(conditionnal_proc, true)  # I received true! :)\nputs await FiberPromise.new(conditionnal_proc, false) # {false, \"I received false... :(\"}\n```\n\n#### Error handling\n\nErrors can be thrown inside a Promise, and are caught for you : the return value will be the Exception raised\n\n```crystal\npromise = FiberPromise.new(->{\n  raise \"Oh, no!\"\n})\n\nvalue = await promise\nputs value  # Oh, no!\nputs value.class  # Exception\n```\n\n#### Resolve / Reject\n\nWhen you're inside a promise, prefere using `resolve` and `reject`, instead of `return` and `raise`.\n\nBasically, it does the same thing, but indicates you're handling a Promise, and not something else\n\n```crystal\nconditionnal_proc = ->(toggle : Bool) do\n  if toggle\n    resolve \"I received true! :)\"\n  end\n  resolve false, \"I received false... :(\"\nend\nputs await FiberPromise.new(conditionnal_proc, true)  # I received true! :)\nputs await FiberPromise.new(conditionnal_proc, false) # {false, \"I received false... :(\"\n```\n\n`reject` works the same way `raise` works, so you can reject either a String or an Exception\n\n```crystal\npromise = FiberPromise.new(->{\n  reject \"Oh, no!\"\n})\n\nvalue = await promise\nputs value  # Oh, no!\nputs value.class  # Exception\n\npromise = FiberPromise.new(->{\n  reject Exception.new(\"Oh, no!\")\n})\n\nvalue = await promise\nputs value  # Oh, no!\nputs value.class  # Exception\n```\n\n#### Callbacks (.then / .catch)\n\n> Promise callbacks are still under development! Don't use it for the moment, as it's still not stable.\n\nCallbacks are pieces of code which will be executed AFTER your Promise, asynchronously. You can add a callback like this :\n\n```crystal\nFiberPromise.new(->{\n  # do something\n}).then(->{\n  # will be executed once the Promise is RESOLVED\n})\n```\n\n.then is for adding callbacks on RESOlVE\n\nYou can use .catch for adding callbacks on REJECT\n\n```crystal\nFiberPromise.new(->{\n  reject \"oh no!\"\n}).catch((e : Exception)->{\n  puts \"{e.message}\"\n})\n```\n\nYou can have callbacks on RESOLVE and REJECT simultaneously, to execute code depending on the promise state.\n\n```crystal\npromise = FiberPromise.new(->{\n  # Do something\n})\n\npromise.then(->{ \"RESOLVED\" })\npromise.catch(->{ \"REJECTED\" })\n```\n\nNotice that adding a callback on a state will override the older one on the same state\n\n#### .finally\n\nWith .finally, you can add callback which will be called in any case\n\n```crystal\nFiberPromise.new(->{\n  # Do something\n}).finally({\n  # Will be called either if the Promise was RESOLVED or REJECTED\n})\n```\n\n#### Chaining callbacks\n\nAdding a callback return a new Promise object\n\nIt means you can chain callbacks, like this :\n\n```crystal\nFiberPromise.new(->{\n  # Do something\n}).then(->{\n  \"RESOLVED\"\n}).catch(->{\n  \"REJECTED\"\n}).finally(->{\n  \"ANY CASE\"\n})\n```\n\nIf, for example, an error is thrown, every THEN blocks will be skipped until a CATCH or FINALLY block is found\n\n```crystal\nFiberPromise.new(->{\n  reject \"Oh no!\"\n}).then(->{\n  \"I won't be called if an error is thrown...\"\n}).catch(->{\n  \"Gotcha!\"\n})\n```\n\nWith this, you can totally control your asynchronous flow :) enjoy!\n\n___\n\n### Pool\n\nAsync offer you different kinds of workers pool :\n - FiberPool\n - ThreadPool (In developpement)\n - ProcessPool (Not implemented yet)\n\nEach pool has the same api (see Documentation)\n\nHere is an example using a FiberPool, but this works with any kind of pool!\n\n#### Creating a pool\n\nKeep in mind that here, a worker is a crystal Fiber. With a ThreadPool, it would have been a Thread, and with a ProcessPool, an entire Process\n\n```crystal\npool = FiberPool.new(3) # Create and launch a pool with 3 workers\n```\n\n#### Adding jobs\n\nYou can add jobs by multiple way :\n - From a block, using do/end notation\n\n```crystal\npool.push(->do\n  puts \"hello\"\nend)\n```\n\n - From a block, using bracket notation\n\n```crystal\npool.push(->(i : Int32) { puts i }, 12)\n# Notice that arguments are givent after the Proc!\n# If you forget one argument, your code won't compile\n```\n\n - From an existing function\n\n```crystal\ndef my_function(x : Int32, y : Int32)\n  sleep 1.seconds\n  puts x\n  sleep 3.seconds\n  puts y\n  \"hello\"\nend\n\nmy_function_proc = ->my_function(Int32, Int32)\npool.push(my_function_proc, 1, 2)\n# Or simply\npool.push(->my_function(Int32, Int32), 1, 2)\n```\n\n - You can add a job with the `wait_for` method too. It'll block the execution until a worker has picked and executed this job\n\n```crystal\nfiber_pool.wait_for(->{\n  puts \"Let's sleep a bit\"\n  sleep 3.seconds\n  puts \"I'm done with sleeping!\"\n})\n# Execution will continue once \"I'm done with sleeping!\" have been displayed\n```\n\n#### Pool control\n\nAsync give you some way to control your workers pool :\n\n - The `wait` method, blocking the execution until every jobs have been executed\n\n```crystal\npool.wait\n# Execution will continue once every jobs will be finished\n```\n\n - The `finish` method, blocking the execution until every jobs have been executed, and then kill all workers. Notice that you can't use the pool after this, as it's a way to destroy it\n\n```crystal\npool.finish\n# Execution blocked until every jobs will be finished and workers killed\n```\n\n - The `stop` method. Once stop have been called, the pool will finish all currently executed jobs, when kill every workers. Notice that all the pending jobs will be lost! It's usefull when you want to stop the pool without executing all queues tasks. Stop is not a blocking call, but you can't use the pool after this, as it's a way to destroy it\n\n```crystal\npool.stop\n# Execution not blocked, currently started jobs finishing in background, pending jobs lost, and fibers killed in background\n```\n\n - The `terminate` method, killing all workers instataneously, without finishing any job!\n\n```crystal\n# Unfortunatly, not implemented for the moment... Sorry <3\n```\n\n - The `finalize` is used to destroy the pool : it will finish in the background every jobs, and kill workers. It's the equivalent of the `finish` method, but without stoping the execution. As it's a way to destroy the pool, you can't use it after this\n\n```crystal\npool.finalize\n```\n\n## TODO\n\n- [ ] FiberPool\n   - [x] Trying to take any form of procs as arguments (templated Job class)\n   - [x] Simple generic pool with queued jobs\n   - [x] Sleeping fibers, able to be awoken by the FiberPool\n   - [x] Fully asynchronous functioning\n   - [x] \"Joining\" fibers at FiberPool destruction. Offering a way to \"kill\" fibers manually\n   - [ ] Return value of fibers\n   - [x] wait and wait_for methods (respectively, blocking call waiting for ALL jobs to finish, and a blocking call waiting for the job given as parameter to finish)\n   - [x] documented api\n\n- [ ] ThreadPool\n   - [ ] Abstract class above FiberPool and ThreadPool, to make users able to substitute fibers by threads\n   - [ ] Thread class, an encapsulation of pthread_t\n   - [ ] Mutex class, an encapsulation of pthread_mutex_t\n   - [ ] ConditionVariable class, an encapsulation of pthread_cond_t\n   - [ ] SafeQueue, wrapping Dequeu and Mutex\n   - [ ] ThreadChannel, wrapping SafeQueue and ConditionVariable\n   - [ ] ThreadWorker, the worker launched in each threads at the ThreadPool creation! It is sleeping when no jobs are in the ThreadChannel, and awoken when some job is pushed in the ThreadPool\n   - [ ] Threads joining\n   - [ ] Threads return value\n\n- [ ] ProcessPool\n   - [ ] Roadmap to be defined!\n\n- [ ] FiberPromise\n  - [x] Launching generic job in fiber at creation\n  - [x] State and return value\n  - [x] await blocking method implementation\n  - [x] typed await\n  - [x] error throwing\n  - [ ] .then and .catch\n  - [ ] chaining .then and .catch\n  - [ ] .finally\n  - [ ] arguments depending on the callback (possibility to take 0 arguments for a .catch, for example)\n  - [ ] adding multiples callbacks on the same event\n  - [x] resolve and reject keywords\n  - [ ] documented code\n  - [ ] specs\n\n- [ ] ThreadPromise\n   - [ ] Roadmap to be defined!\n\n- [ ] ProcessPromise\n   - [ ] Roadmap to be defined!\n\n\n## Contributing\n\n1. Fork it (<https://github.com/LeChatErrant/async/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [LeChatErrant](https://github.com/LeChatErrant) - creator and maintainer\n","program":{"html_id":"github.com/LeChatErrant/async/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"github.com/LeChatErrant/async","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/LeChatErrant/async/Async","path":"Async.html","kind":"module","full_name":"Async","name":"Async","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"job/generic_job.cr","line_number":1,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/job/generic_job.cr"},{"filename":"job/job.cr","line_number":3,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/job/job.cr"},{"filename":"pool/pool.cr","line_number":1,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/pool.cr"},{"filename":"logger/logger.cr","line_number":3,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/logger/logger.cr"},{"filename":"pool/fiber_pool.cr","line_number":7,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr"},{"filename":"promise/promise.cr","line_number":1,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr"},{"filename":"return_value/generic_return_value.cr","line_number":1,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/generic_return_value.cr"},{"filename":"return_value/return_value.cr","line_number":3,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/return_value.cr"},{"filename":"function/generic_function.cr","line_number":1,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/function/generic_function.cr"},{"filename":"function/function.cr","line_number":3,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/function/function.cr"},{"filename":"promise/fiber_promise.cr","line_number":7,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr"},{"filename":"async.cr","line_number":4,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/async.cr"}],"repository_name":"github.com/LeChatErrant/async","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.2.0\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"await(type:T.class,promise:Promise)forallT-instance-method","html_id":"await(type:T.class,promise:Promise)forallT-instance-method","name":"await","doc":null,"summary":null,"abstract":false,"args":[{"name":"type","doc":null,"default_value":"","external_name":"type","restriction":"T.class"},{"name":"promise","doc":null,"default_value":"","external_name":"promise","restriction":"Promise"}],"args_string":"(type : <span class=\"t\">T</span>.<span class=\"k\">class</span>, promise : Promise) forall T","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr#L6","def":{"name":"await","args":[{"name":"type","doc":null,"default_value":"","external_name":"type","restriction":"T.class"},{"name":"promise","doc":null,"default_value":"","external_name":"promise","restriction":"Promise"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"puts(T)\npromise.wait.as(T)\n"}},{"id":"await(promise:Promise)-instance-method","html_id":"await(promise:Promise)-instance-method","name":"await","doc":null,"summary":null,"abstract":false,"args":[{"name":"promise","doc":null,"default_value":"","external_name":"promise","restriction":"Promise"}],"args_string":"(promise : Promise)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr#L2","def":{"name":"await","args":[{"name":"promise","doc":null,"default_value":"","external_name":"promise","restriction":"Promise"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"promise.wait"}},{"id":"reject(message:String):NoReturn-instance-method","html_id":"reject(message:String):NoReturn-instance-method","name":"reject","doc":null,"summary":null,"abstract":false,"args":[{"name":"message","doc":null,"default_value":"","external_name":"message","restriction":"String"}],"args_string":"(message : String) : NoReturn","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr#L15","def":{"name":"reject","args":[{"name":"message","doc":null,"default_value":"","external_name":"message","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"NoReturn","visibility":"Public","body":"raise(Exception.new(message))"}},{"id":"reject(exception:Exception):NoReturn-instance-method","html_id":"reject(exception:Exception):NoReturn-instance-method","name":"reject","doc":null,"summary":null,"abstract":false,"args":[{"name":"exception","doc":null,"default_value":"","external_name":"exception","restriction":"Exception"}],"args_string":"(exception : Exception) : NoReturn","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr#L19","def":{"name":"reject","args":[{"name":"exception","doc":null,"default_value":"","external_name":"exception","restriction":"Exception"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"NoReturn","visibility":"Public","body":"raise(exception)"}}],"macros":[{"id":"resolve(*values)-macro","html_id":"resolve(*values)-macro","name":"resolve","doc":null,"summary":null,"abstract":false,"args":[{"name":"values","doc":null,"default_value":"","external_name":"values","restriction":""}],"args_string":"(*values)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr#L11","def":{"name":"resolve","args":[{"name":"values","doc":null,"default_value":"","external_name":"values","restriction":""}],"double_splat":null,"splat_index":0,"block_arg":null,"visibility":"Public","body":"    return \n{{ *values }}\n\n  \n"}}],"types":[{"html_id":"github.com/LeChatErrant/async/Async/AsyncLogger","path":"Async/AsyncLogger.html","kind":"module","full_name":"Async::AsyncLogger","name":"AsyncLogger","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"logger/logger.cr","line_number":4,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/logger/logger.cr"}],"repository_name":"github.com/LeChatErrant/async","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[{"html_id":"github.com/LeChatErrant/async/Async/FiberPool","kind":"class","full_name":"Async::FiberPool","name":"FiberPool"},{"html_id":"github.com/LeChatErrant/async/Async/FiberPromise","kind":"class","full_name":"Async::FiberPromise(*T, R)","name":"FiberPromise"}],"namespace":{"html_id":"github.com/LeChatErrant/async/Async","kind":"module","full_name":"Async","name":"Async"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"verbose_level=(level:Logger::Severity)-instance-method","html_id":"verbose_level=(level:Logger::Severity)-instance-method","name":"verbose_level=","doc":"Change the level of severity beyond which the logger of your `FTPServer` will print logs\n\nNOTE: When building in release mode, the severity is by default at Logger::ERROR. Otherwise, it is set by default at Logger::INFO","summary":"<p>Change the level of severity beyond which the logger of your <code>FTPServer</code> will print logs</p>","abstract":false,"args":[{"name":"level","doc":null,"default_value":"","external_name":"level","restriction":"Logger::Severity"}],"args_string":"(level : Logger::Severity)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/logger/logger.cr#L17","def":{"name":"verbose_level=","args":[{"name":"level","doc":null,"default_value":"","external_name":"level","restriction":"Logger::Severity"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@logger.level = level"}}],"macros":[{"id":"default_severity_level-macro","html_id":"default_severity_level-macro","name":"default_severity_level","doc":"Default severity level for the logger : INFO by default, ERROR when building in release mode","summary":"<p>Default severity level for the logger : INFO by default, ERROR when building in release mode</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/logger/logger.cr#L6","def":{"name":"default_severity_level","args":[],"double_splat":null,"splat_index":null,"block_arg":null,"visibility":"Public","body":"      \n{% if flag?(:release) %}\n        Logger::ERROR\n      {% else %}\n        Logger::INFO\n      {% end %}\n\n    \n"}}],"types":[]},{"html_id":"github.com/LeChatErrant/async/Async/FiberPool","path":"Async/FiberPool.html","kind":"class","full_name":"Async::FiberPool","name":"FiberPool","abstract":false,"superclass":{"html_id":"github.com/LeChatErrant/async/Async/Pool","kind":"class","full_name":"Async::Pool","name":"Pool"},"ancestors":[{"html_id":"github.com/LeChatErrant/async/Async/AsyncLogger","kind":"module","full_name":"Async::AsyncLogger","name":"AsyncLogger"},{"html_id":"github.com/LeChatErrant/async/Async/Pool","kind":"class","full_name":"Async::Pool","name":"Pool"},{"html_id":"github.com/LeChatErrant/async/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/LeChatErrant/async/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"pool/fiber_pool.cr","line_number":8,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr"}],"repository_name":"github.com/LeChatErrant/async","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/LeChatErrant/async/Async/AsyncLogger","kind":"module","full_name":"Async::AsyncLogger","name":"AsyncLogger"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/LeChatErrant/async/Async","kind":"module","full_name":"Async","name":"Async"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(nb_of_workers:Int32,verbose_level=default_severity_level)-class-method","html_id":"new(nb_of_workers:Int32,verbose_level=default_severity_level)-class-method","name":"new","doc":"Launch a pool, with `nb_of_workers` workers. As it's a fiber pool, each worker is a `Fiber`","summary":"<p>Launch a pool, with <code>nb_of_workers</code> workers.</p>","abstract":false,"args":[{"name":"nb_of_workers","doc":null,"default_value":"","external_name":"nb_of_workers","restriction":"Int32"},{"name":"verbose_level","doc":null,"default_value":"default_severity_level","external_name":"verbose_level","restriction":""}],"args_string":"(nb_of_workers : Int32, verbose_level = default_severity_level)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr#L82","def":{"name":"new","args":[{"name":"nb_of_workers","doc":null,"default_value":"","external_name":"nb_of_workers","restriction":"Int32"},{"name":"verbose_level","doc":null,"default_value":"default_severity_level","external_name":"verbose_level","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(nb_of_workers, verbose_level)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"finalize-instance-method","html_id":"finalize-instance-method","name":"finalize","doc":"Finish every jobs, currently executed or pending, destroy all workers and the pool itself","summary":"<p>Finish every jobs, currently executed or pending, destroy all workers and the pool itself</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr#L194","def":{"name":"finalize","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@logger.info(\"[FiberPool#finalize] Fiber pool is finishing to work in the background...\")\n@is_working = false\nwhile (@available > 0)\n  @available = @available - 1\n  @channel.send(nil)\nend\n"}},{"id":"finish-instance-method","html_id":"finish-instance-method","name":"finish","doc":"Wait for every jobs to finish, and destroy all workers\n\nNOTE: Blocking call\nNOTE: The pool is no more available after this (no worker left!)","summary":"<p>Wait for every jobs to finish, and destroy all workers</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr#L168","def":{"name":"finish","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@logger.info(\"[FiberPool#finish] Finishing fiber pool...\")\n@is_waiting_death = true\n@is_working = false\n@fibers.size.times do\n  while (  @available > 0)\n    @available = @available - 1\n    @channel.send(nil)\n  end\n  @death_channel.receive\nend\n@logger.info(\"[FiberPool#finish] Fiber pool finished!\")\n"}},{"id":"push(callable,*args)-instance-method","html_id":"push(callable,*args)-instance-method","name":"push","doc":"Add a job to the pool. When a worker will be available, it'll pick the job and execute it.\n\n`#push` takes any type of `Proc` as argument, and all the arguments to be passed to the proc when it'll be called\n\nNotice that your code won't compile if you forget one argument\n\nProc without arguments\n```\npool.push(->{ puts \"hello\" })\n```\n\nProc with arguments\n```\npool.push(->(i : Int32, str : String) { puts \"#{str} : #{i}\" }, 12, \"Hello, number\")\n```\n\nFrom function\n```\ndef welcome(name : String)\n  puts \"Hello, #{name}!\"\n  name\nend\n\nwelcome_proc = ->welcome(String)\npool.push(welcome_proc, \"John\")\n# Or simply\npool.push(->welcome(String), \"John\")\n```","summary":"<p>Add a job to the pool.</p>","abstract":false,"args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(callable, *args)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr#L115","def":{"name":"push","args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":1,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"job = capture(callable, args)\nsend_job(job)\n@logger.debug(\"[FiberPool#push] Job added in FiberPool queue\")\n"}},{"id":"stop-instance-method","html_id":"stop-instance-method","name":"stop","doc":"Tell the pool to finish all currently executed jobs, then to kill all workers\n\nNOTE: All the pending queued jobs won't be executed and are lost\nNOTE: The pool is no more available after this (no worker left!)","summary":"<p>Tell the pool to finish all currently executed jobs, then to kill all workers</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr#L155","def":{"name":"stop","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@logger.info(\"[@FiberPool#stop] Fiber pool is finishing currently executed jobs...\")\n@jobs.clear\n@fibers.size.times do\n  send_job(nil)\nend\n@logger.info(\"[@FiberPool#stop] Fiber pool finished current jobs! It's closing, without executing pending jobs!\")\n"}},{"id":"terminate-instance-method","html_id":"terminate-instance-method","name":"terminate","doc":"Kill instantaneously all workers\n\nNOTE: The pool is no more available after this\nTODO: Not implemented yet","summary":"<p>Kill instantaneously all workers</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr#L186","def":{"name":"terminate","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@logger.warn(\"[FiberPool#terminate] Terminating fiber pool!\")\n@logger.error(\"[FiberPool#terminate] Not implemented yet!\")\n"}},{"id":"wait-instance-method","html_id":"wait-instance-method","name":"wait","doc":"Wait for every jobs to finish\n\nNOTE: Blocking call","summary":"<p>Wait for every jobs to finish</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr#L124","def":{"name":"wait","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@logger.info(\"[FiberPool#wait] Fiber pool waiting for all jobs to finish...\")\n@is_waiting = true\nwhile (@available < @fibers.size)\n  @wait_channel.receive\nend\n@is_waiting = false\n@logger.info(\"[FiberPool#wait] All jobs finished!\")\n"}},{"id":"wait_for(callable,*args)-instance-method","html_id":"wait_for(callable,*args)-instance-method","name":"wait_for","doc":"Add a job to the pool, and block the execution until this job is done\n\nNOTE: Blocking call","summary":"<p>Add a job to the pool, and block the execution until this job is done</p>","abstract":false,"args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(callable, *args)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/pool/fiber_pool.cr#L137","def":{"name":"wait_for","args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":""},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":1,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"job = capture(callable, args)\nlocal_channel = Channel(Nil).new\nwrapper_proc = ->(arg : typeof(job)) do\n  arg.dup.call\n  local_channel.send(nil)\nend\nwrapped_job = capture(wrapper_proc, {job})\nsend_job(wrapped_job)\n@logger.info(\"[FiberPool#wait_for] Fiber pool is waiting for #{typeof(callable)} to be executed...\")\nlocal_channel.receive\n@logger.info(\"[FiberPool#wait_for] Fiber pool finished waiting for #{typeof(callable)}!\")\n"}}],"macros":[],"types":[]},{"html_id":"github.com/LeChatErrant/async/Async/FiberPromise","path":"Async/FiberPromise.html","kind":"class","full_name":"Async::FiberPromise(*T, R)","name":"FiberPromise","abstract":false,"superclass":{"html_id":"github.com/LeChatErrant/async/Async/Promise","kind":"class","full_name":"Async::Promise","name":"Promise"},"ancestors":[{"html_id":"github.com/LeChatErrant/async/Async/AsyncLogger","kind":"module","full_name":"Async::AsyncLogger","name":"AsyncLogger"},{"html_id":"github.com/LeChatErrant/async/Async/Promise","kind":"class","full_name":"Async::Promise","name":"Promise"},{"html_id":"github.com/LeChatErrant/async/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/LeChatErrant/async/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"promise/fiber_promise.cr","line_number":20,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr"}],"repository_name":"github.com/LeChatErrant/async","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/LeChatErrant/async/Async/AsyncLogger","kind":"module","full_name":"Async::AsyncLogger","name":"AsyncLogger"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/LeChatErrant/async/Async","kind":"module","full_name":"Async","name":"Async"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(callable:Proc(*T,R),*args)-class-method","html_id":"new(callable:Proc(*T,R),*args)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":"Proc(*T, R)"},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(callable : Proc(<span class=\"o\">*</span><span class=\"t\">T</span>, R), *args)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr#L33","def":{"name":"new","args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":"Proc(*T, R)"},{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":1,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = FiberPromise(*T, R).allocate\n_.initialize(callable, *args)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"catch(callable:T)forallT-instance-method","html_id":"catch(callable:T)forallT-instance-method","name":"catch","doc":null,"summary":null,"abstract":false,"args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":"T"}],"args_string":"(callable : T) forall T","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr#L82","def":{"name":"catch","args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":""}},{"id":"finally(callable)-instance-method","html_id":"finally(callable)-instance-method","name":"finally","doc":null,"summary":null,"abstract":false,"args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":""}],"args_string":"(callable)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr#L85","def":{"name":"finally","args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":""}},{"id":"get-instance-method","html_id":"get-instance-method","name":"get","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr#L62","def":{"name":"get","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if state != PromiseState::PENDING\n  @return_value.try(&.get)\nelse\n  @state\nend"}},{"id":"state-instance-method","html_id":"state-instance-method","name":"state","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr#L92","def":{"name":"state","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@state"}},{"id":"then(callable:T)forallT-instance-method","html_id":"then(callable:T)forallT-instance-method","name":"then","doc":null,"summary":null,"abstract":false,"args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":"T"}],"args_string":"(callable : T) forall T","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr#L70","def":{"name":"then","args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"FiberPromise.new(->(this : self, callback : T) do\n  value = await(this)\n  if value.is_a?(Tuple)\n    tmp = Function.new(*value)\n    tmp.wrap(callback)\n  else\n    puts(\"not implemented yet!\")\n  end\nend, self, callable)"}},{"id":"to_s(io:IO):Nil-instance-method","html_id":"to_s(io:IO):Nil-instance-method","name":"to_s","doc":null,"summary":null,"abstract":false,"args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":"IO"}],"args_string":"(io : IO) : Nil","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr#L88","def":{"name":"to_s","args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":"IO"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Nil","visibility":"Public","body":"io << \"#<Async::FiberPromise:#{self.object_id}> #{@state}\""}},{"id":"wait-instance-method","html_id":"wait-instance-method","name":"wait","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/fiber_promise.cr#L49","def":{"name":"wait","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if state != PromiseState::PENDING\n  @return_value.try(&.get)\nelse\n  @is_waiting = true\n  @channel.receive\n  @return_value.try(&.get)\nend"}}],"macros":[],"types":[]},{"html_id":"github.com/LeChatErrant/async/Async/Function","path":"Async/Function.html","kind":"class","full_name":"Async::Function(*T)","name":"Function","abstract":false,"superclass":{"html_id":"github.com/LeChatErrant/async/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/LeChatErrant/async/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/LeChatErrant/async/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"function/function.cr","line_number":4,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/function/function.cr"}],"repository_name":"github.com/LeChatErrant/async","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/LeChatErrant/async/Async","kind":"module","full_name":"Async","name":"Async"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(*args:*T)-class-method","html_id":"new(*args:*T)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":"*T"}],"args_string":"(*args : <span class=\"o\">*</span><span class=\"t\">T</span>)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/function/function.cr#L5","def":{"name":"new","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":"*T"}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = Function(*T).allocate\n_.initialize(*args)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"wrap(callable)-instance-method","html_id":"wrap(callable)-instance-method","name":"wrap","doc":null,"summary":null,"abstract":false,"args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":""}],"args_string":"(callable)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/function/function.cr#L9","def":{"name":"wrap","args":[{"name":"callable","doc":null,"default_value":"","external_name":"callable","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"{% if true %}\n        {% for i in 0...T.size %}\n          puts {{ T[i] }}\n        {% end %}\n      {% end %}"}}],"macros":[],"types":[]},{"html_id":"github.com/LeChatErrant/async/Async/GenericReturnValue","path":"Async/GenericReturnValue.html","kind":"class","full_name":"Async::GenericReturnValue","name":"GenericReturnValue","abstract":true,"superclass":{"html_id":"github.com/LeChatErrant/async/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/LeChatErrant/async/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/LeChatErrant/async/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"return_value/generic_return_value.cr","line_number":2,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/generic_return_value.cr"}],"repository_name":"github.com/LeChatErrant/async","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[{"html_id":"github.com/LeChatErrant/async/Async/ReturnValue","kind":"class","full_name":"Async::ReturnValue(T)","name":"ReturnValue"}],"including_types":[],"namespace":{"html_id":"github.com/LeChatErrant/async/Async","kind":"module","full_name":"Async","name":"Async"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(value)-class-method","html_id":"new(value)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"args_string":"(value)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/generic_return_value.cr#L3","def":{"name":"new","args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(value)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"get-instance-method","html_id":"get-instance-method","name":"get","doc":null,"summary":null,"abstract":true,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/generic_return_value.cr#L4","def":{"name":"get","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":""}},{"id":"type-instance-method","html_id":"type-instance-method","name":"type","doc":null,"summary":null,"abstract":true,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/generic_return_value.cr#L5","def":{"name":"type","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":""}}],"macros":[],"types":[]},{"html_id":"github.com/LeChatErrant/async/Async/PromiseState","path":"Async/PromiseState.html","kind":"enum","full_name":"Async::PromiseState","name":"PromiseState","abstract":false,"superclass":null,"ancestors":[{"html_id":"github.com/LeChatErrant/async/Enum","kind":"struct","full_name":"Enum","name":"Enum"},{"html_id":"github.com/LeChatErrant/async/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/LeChatErrant/async/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"github.com/LeChatErrant/async/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"promise/promise.cr","line_number":23,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr"}],"repository_name":"github.com/LeChatErrant/async","program":false,"enum":true,"alias":false,"aliased":"","const":false,"constants":[{"id":"PENDING","name":"PENDING","value":"0","doc":null,"summary":null},{"id":"RESOLVED","name":"RESOLVED","value":"1","doc":null,"summary":null},{"id":"REJECTED","name":"REJECTED","value":"2","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/LeChatErrant/async/Async","kind":"module","full_name":"Async","name":"Async"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"pending?-instance-method","html_id":"pending?-instance-method","name":"pending?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr#L24","def":{"name":"pending?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == PENDING"}},{"id":"rejected?-instance-method","html_id":"rejected?-instance-method","name":"rejected?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr#L26","def":{"name":"rejected?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == REJECTED"}},{"id":"resolved?-instance-method","html_id":"resolved?-instance-method","name":"resolved?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/promise/promise.cr#L25","def":{"name":"resolved?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == RESOLVED"}}],"macros":[],"types":[]},{"html_id":"github.com/LeChatErrant/async/Async/ReturnValue","path":"Async/ReturnValue.html","kind":"class","full_name":"Async::ReturnValue(T)","name":"ReturnValue","abstract":false,"superclass":{"html_id":"github.com/LeChatErrant/async/Async/GenericReturnValue","kind":"class","full_name":"Async::GenericReturnValue","name":"GenericReturnValue"},"ancestors":[{"html_id":"github.com/LeChatErrant/async/Async/GenericReturnValue","kind":"class","full_name":"Async::GenericReturnValue","name":"GenericReturnValue"},{"html_id":"github.com/LeChatErrant/async/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/LeChatErrant/async/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"return_value/return_value.cr","line_number":4,"url":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/return_value.cr"}],"repository_name":"github.com/LeChatErrant/async","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/LeChatErrant/async/Async","kind":"module","full_name":"Async","name":"Async"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(value:T)-class-method","html_id":"new(value:T)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"args_string":"(value : T)","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/return_value.cr#L5","def":{"name":"new","args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = ReturnValue(T).allocate\n_.initialize(value)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"get-instance-method","html_id":"get-instance-method","name":"get","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/return_value.cr#L8","def":{"name":"get","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@value"}},{"id":"type-instance-method","html_id":"type-instance-method","name":"type","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/LeChatErrant/async/blob/0d1a5a85af9e3601f350e3e1f8edfa5fd4b19f89/src/return_value/return_value.cr#L12","def":{"name":"type","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"typeof(@value)"}}],"macros":[],"types":[]}]}]}})